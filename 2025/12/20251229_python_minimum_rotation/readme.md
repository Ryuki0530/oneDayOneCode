# OneDayOneCode（今日の課題）: 文字列の「最小回転」(Minimum Rotation)

## 概要
文字列 S を円環（ぐるっと一周つながってる）とみなして、回転させた文字列のうち
**辞書順で最小**になる回転を求めて出力してください。

例: `bbaacca` の回転候補は      
`bbaacca, baaccab, aaccabb, accabba, ccabbaa, cabbaac, abbaacc`  
この中で最小は `aaccabb`

今日は **C言語** 想定（Windows11 / VSCode）。アルゴリズム寄りで、文字列カウンタ系じゃないやつ。

---

## 問題
標準入力で 1 行の文字列 `S`（空白なし、長さ 1〜200000）を受け取り、  
`S` の回転（先頭を k 文字切って末尾へ付ける）で得られる文字列のうち、
辞書順最小のものを 1 行で出力してください。

---

## 入力例
bbaacca

## 出力例
aaccabb

---

## 仕様
- 文字集合は ASCII として扱ってよい（英数記号が混ざってもOK）
- 回転量 k は 0〜|S|-1 のどれか
- 出力は最小の回転文字列そのもの

---

## 制約と目標
- O(n^2) は長さ 20万で死にます。**O(n)** か **O(n log n)** を狙う。
- 追加メモリは O(n) 程度までOK

---

## ヒント（やり方の方向性だけ）
- 有名解法：**Booth’s algorithm**（ブースのアルゴリズム）で O(n)
- 考え方：`S+S` 上で「最小の開始位置」を1本のポインタ操作で探す

---

## 実装メモ（Cで困りがちな所）
- `S` の長さ n を取って、比較は `S[(i+k)%n]` でも良いが遅いので
  `T = S + S` を作って `T[i+k]` で比較するのが楽（長さ 2n）
- 出力は `T[pos ... pos+n-1]`

---

## 追加チャレンジ（余力）
- 同じ最小回転が複数ある場合（例: `aaaa`）でも正しく動くことを確認
- 最小回転の開始インデックス（0-based）も一緒に出す `pos:<index> <string>`
