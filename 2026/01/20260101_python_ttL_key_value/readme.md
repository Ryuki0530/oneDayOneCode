# 今日のPython課題（手短）：TTL付きキー・バリュー（遅延削除）

## 概要
「キー → 値」を保存する辞書っぽいものを作ります。ただし **各キーには有効期限（TTL: 秒）** があり、期限を過ぎたキーは `get` すると `-1` を返します。  
削除は「毎秒掃除」みたいな重いことはせず、**アクセス時にだけ期限切れを片付ける（遅延削除）** 方式でOK。

## 入力
1行目：整数 `Q`（クエリ数）  
2行目以降：次のいずれかのクエリ

- `SET key value ttl now`
  - `key` は文字列（空白なし）
  - `value` は整数
  - `ttl` は整数（秒）
  - `now` は整数（現在時刻）
  - この操作で、その `key` は **時刻 `now + ttl` まで有効** とする

- `GET key now`
  - `now` は整数（現在時刻）
  - 有効なら `value`、期限切れ or 無ければ `-1` を出力

- `DEL key`
  - あれば削除（出力なし）

## 出力
`GET` クエリごとに1行、結果を出力。

## 制約（雑でOK）
- `1 <= Q <= 2*10^5` くらいを想定（でも実装はシンプルでOK）
- `now` は非減少とは限らない（ここが地味に罠）
  - なので「全体を now で掃除」ではなく、**key単位の期限判定**が安全

## 実装要件
- データ構造は `dict` 1つ（または2つ）でOK
- 各キーについて `value` と `expire_time` を保持すること
- `GET` のときに `expire_time <= now` なら、その場で辞書から消して `-1`

## 例
入力:
6
SET a 10 5 3
GET a 7
GET a 8
SET a 99 2 8
GET a 9
GET a 11

出力:
10
-1
99
-1

説明:
- a は 3+5=8 まで有効。now=7 はOK、now=8 は期限切れ扱い（expire_time <= now で切れる）
- 次に a を now=8 で ttl=2 → expire=10
- now=9 はOK、now=11 は期限切れ

## ゴール
標準入力から処理して、`GET` の答えを出せ。
（クラス化は不要。関数1つでもOK）
