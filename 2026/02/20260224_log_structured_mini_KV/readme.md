# 今日のPython課題：Log-Structured Mini-KV（追記ログ方式のミニKVS）

## 背景
TTL（時間で失効）みたいな“時間”依存を捨てて、**ディスクに追記するだけ**で動くミニKVSを作ります。  
イメージは「ログを積み上げて、必要なら圧縮（compaction）で掃除する」方式です。

---

## 問題
標準入力でコマンド列を受け取り、標準出力に結果を出すプログラム `main.py` を作ってください。

あなたは **追記ログファイル** と **インデックス（メモリ上の辞書）** を使って、キーと値を管理します。

---

## 入力（コマンド）
1行に1コマンド。`EOF` まで続きます。

- `PUT key value`
  - keyにvalueを保存（上書き）
- `GET key`
  - keyの最新valueを出力。存在しなければ `NOT_FOUND`
- `DEL key`
  - keyを削除（論理削除）
- `COUNT`
  - 現在「存在するキー数」を出力（削除済みは数えない）
- `COMPACT`
  - ログを圧縮して、不要な古い履歴や削除マーカーを捨てる

---

## 出力
- `GET` は `value` または `NOT_FOUND`
- `COUNT` は整数
- `COMPACT` は `OK` を出力（成功したら）

---

## 実装要件
### 1) ログ形式（自分で決めてOK）
ただし以下を満たしてください：
- 1レコードは「操作種別 + key + value（必要なら）」を表現できる
- 追記で書ける
- 再起動（プログラム再実行）しても復元できる（= 起動時にログを読み直してインデックス再構築）

おすすめ案（例）：
- 1行1レコードのテキスト（JSON Lines でも可）
- あるいはバイナリ（長さ付き）でも可（難しめ）

### 2) インデックス
- `dict[key] = (offset, length)` のように **ログ内の位置** を持つ（valueを丸ごと持つのは不可にしてみよう）
- `GET` はログをseekして value を読みにいく

### 3) COMPACT（圧縮）
- 現時点で有効な最新値だけを新ログに書き出し、古いログを置き換える
- 削除済みのキーは新ログに残さない
- インデックスも作り直す

### 4) 制約（目安）
- コマンド数：最大 200000 を想定（O(N)やらかすと遅い）
- key, value はスペースを含まない（楽にするため）
- key長 <= 32, value長 <= 256 くらいを想定

---

## 例
### 入力
PUT a 10
PUT b 20
GET a
DEL a
GET a
COUNT
PUT b 30
COMPACT
GET b
COUNT

### 出力
10
NOT_FOUND
1
OK
30
1

---

## 追加チャレンジ（任意）
- `COMPACT` 中にクラッシュしても壊れないようにする（テンポラリ→rename）
- ログが巨大化したら自動compaction（例：ログサイズが有効データの3倍を超えたら）
- `PUT` が同じ値なら書かない最適化（でもログ構造的に注意）

---

## ヒント：使う標準ライブラリ
- `open(..., "ab")`, `open(..., "rb")`
- `file.seek(offset)`, `file.read(n)`
- `os.replace(src, dst)`（Windowsでも原子的に置換しやすい）
- `sys.stdin` で高速入力

---

## ゴール
「追記ログ + インデックス + compaction」という、DBの超ミニチュアを手で作って
“永続化と更新”を時間要素なしで扱えるようになること。