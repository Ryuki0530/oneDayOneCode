# 今日の課題（Python）: TTL付きキー・バリュー・ストア（遅延削除 + 定期クリーンアップ）

## 概要
「キーに値を保存する。ただし有効期限（TTL: seconds）が切れたら読めない」を満たす **TTL付きKVS** を作ってください。  
時間がない想定なので、**標準入力→標準出力の1ファイル**でOK。

---

## 仕様
次のコマンド列を処理してください。

### コマンド
- `PUT key value ttl`
  - `key` に `value` を保存し、**ttl秒**後に期限切れとする
  - 同じ `key` が既にある場合は上書き（期限も更新）
- `GET key`
  - 期限内なら `value` を出力
  - 無い / 期限切れなら `NULL` を出力
- `SLEEP t`
  - 仮想時刻を `t` 秒進める（実際に sleep しない）
- `CLEAN`
  - 期限切れデータをまとめて削除（クリーンアップ）

---

## 入力形式
1行目: `Q`（クエリ数）  
2行目以降: Q行のコマンド

- `key`, `value` は空白を含まない文字列
- `ttl`, `t` は整数（0以上）

---

## 出力
`GET` のたびに1行出力。

---

## 実装条件（ミニ）
- **実時間は禁止**（`time.time()` など使わない）。`SLEEP` による **仮想時刻** を使う。
- `GET` で期限切れに遭遇したら、その場で消してもいい（遅延削除）。
- `CLEAN` は効率よくやる（例：期限の早い順に片付ける仕組みを考える）。
  - ヒント：`heapq`（優先度付きキュー）で「(expires_at, key)」を持つと気持ちいい。

---

## 例
### 入力
6
PUT a apple 5
GET a
SLEEP 5
GET a
PUT a orange 3
GET a

### 出力
apple
NULL
orange

---

## クリア条件
- 例が通る
- `PUT/GET/SLEEP/CLEAN` が仕様通り
- `CLEAN` が **全件走査だけ** に頼らない（最低でも工夫がある）

---

## 追加ヒント（最短で通す設計）
- `now`（仮想時刻）を持つ
- `store: dict[key] = (value, expires_at)`
- `pq: heap` に `(expires_at, key)` を push（上書きで古い期限が残るのはOK）
- `CLEAN` では heap の先頭から見て、`expires_at <= now` なら
  - `store` 側の expires と一致する時だけ削除（一致しなければ古い情報なので捨てる）

---

## 余力があれば
- `GET` の前に自動で `CLEAN` 相当の処理を少しだけ走らせて「溜まりすぎ」防止
- `ttl=0` の扱い（即期限切れ）