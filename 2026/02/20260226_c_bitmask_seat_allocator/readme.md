# 今日のC課題: “Bitmask Seat Allocator”

## 問題
座席が **0〜63** の64席あるとする。  
空席/使用中を **64bitのビットマスク**（`uint64_t`）で管理し、以下のコマンドを処理せよ。

- `RESERVE k` : 先頭（小さい番号）から空席を探し、**連続k席**を確保する  
  - 確保できたら、その開始席番号 `s` を出力（確保席は `s..s+k-1`）
  - できなければ `-1` を出力
- `CANCEL s k` : `s..s+k-1` を解放する（範囲外は無視してよい）
- `STATUS` : 現在の使用中席数を出力（popcount）
- `PRINT` : ビット列を出力（席0がLSB）。例: `00101...` のように **64文字**

## 入力
1行目: `Q`（コマンド数）  
続くQ行: 上記コマンド

## 出力
`RESERVE` と `STATUS` と `PRINT` の結果を行ごとに出力。

## 制約
- `1 <= Q <= 2e5`
- `1 <= k <= 64`
- 64bit整数のみで管理すること（配列で64要素を持つのは禁止）

## ヒント（使ってOK）
- 連続k席の候補マスク: `((1ULL<<k)-1) << s`（※k=64のときに注意）
- popcount: `__builtin_popcountll(x)`（GCC/Clang）
- k=64のときは特例で全ビット `~0ULL`

## 例
入力:
5
RESERVE 3
RESERVE 2
CANCEL 1 2
STATUS
PRINT

出力例（例なので一致不要）:
```
0
3
3
11111...（64文字）
```

