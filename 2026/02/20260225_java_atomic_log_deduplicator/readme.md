# 今日のJava課題：Atomic Log Deduplicator（衝突しない重複排除ログ）

## 概要
大量のイベントログ（文字列ID）が流れてきます。  
あなたの仕事は「最近K件の範囲で、同じIDが再登場したら“重複”として数える」ストリーム処理を作ることです。

- 直近 **K件** を「監視窓」とする（スライディングウィンドウ）
- あるイベントIDが **窓内に既に存在** していたら、そのイベントは **重複** としてカウント
- その後、イベントは窓に入る（つまり最新として記録される）
- 窓からは古い順に押し出される

## 入力
1行目：`N K`  
2行目以降：イベントID（文字列）をN行

- `1 <= N <= 200000`
- `1 <= K <= 200000`
- IDは英数字と `_` `-` を含む長さ1〜50程度

## 出力
重複イベントの総数を1行で出力せよ。

## 例
### 入力
```
8 3
A
B
A
C
A
B
D
B
```


### 説明（K=3の窓）
- A(窓: A) 重複0
- B(窓: A,B) 重複0
- A(窓内にAあり) → 重複+1 (窓: A,B,A)
- C(窓: B,A,C)
- A(窓内にAあり) → 重複+1 (窓: A,C,A)
- B(窓内にBは無い) → 重複+0 (窓: C,A,B)
- D(窓: A,B,D)
- B(窓内にBあり) → 重複+1

### 出力
```
3
```


## 実装条件（手短版）
- `O(N)` で通すこと（全探索禁止）
- Java標準ライブラリのみ
- ヒント：`HashMap<String, Integer>` で「窓内の出現回数」を持ち、`ArrayDeque<String>` で窓を管理すると速い

## 追加ヒント（超短）
- 新IDを読む
  - mapにそのIDが1以上なら重複++
  - 窓に追加して map++
  - 窓サイズがKを超えたら古いIDを1つ取り出して map--（0ならremove）