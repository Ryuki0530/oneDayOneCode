# Today’s Java Challenge: Streaming Unique Counter (TTLつき)

## 問題
コマンド列を処理し、**「直近TTL秒以内に観測されたユニークID数」**を高速に答えるプログラムを作成せよ。

入力は時系列順（時刻は非減少）で与えられる。

---

## 入力
最初の1行に `Q TTL` が与えられる。

続く `Q` 行は以下のいずれか：

- `ADD t id`  
  時刻 `t`（整数秒）に `id`（文字列）が観測されたことを追加する
- `COUNT t`  
  時刻 `t` における「(t - TTL, t] の範囲に1回でも出現したユニークid数」を出力する  
  ※左端は **開区間**、右端は **閉区間**（例: TTL=5 のとき、t=10なら対象は 6..10）

制約（目安）
- `1 ≤ Q ≤ 200000`
- `0 ≤ t ≤ 10^9`
- `id` は英数字と `_` のみ（長さ1〜32程度）

---

## 出力
各 `COUNT` ごとに1行、ユニークid数を出力。

---

## 例
入力:
Q TTL
8 5
ADD 1 a
ADD 2 b
COUNT 2
ADD 6 a
COUNT 6
ADD 7 b
ADD 8 c
COUNT 8

出力:
2
1
3

説明:
- t=2 の対象は ( -3, 2 ] → a,b の2種
- t=6 の対象は (1, 6 ] → 2(b)と6(a)だが、1(a)は範囲外なので a のみ → 1
- t=8 の対象は (3, 8 ] → a(6), b(7), c(8) → 3

---

## 実装ヒント（最短ルート）
- `Deque` にイベント `(t, id)` を積む
- `HashMap<String, Integer>` で「現在ウィンドウ内の出現回数」を管理
- `COUNT t` の直前に、`t - TTL` 以下の古いイベントを deque から捨てて map を減算
- map のキー数が答え

---

## クリア条件
- すべての `COUNT` に正しい値を出力できる
- `O(Q)` 近い計算量（各イベントは高々1回追加・1回削除）
- 入力が大きいので `BufferedInputStream` / `FastScanner` 推奨

