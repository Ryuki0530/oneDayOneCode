# 今日の課題: Log Tail（実装版）— リングバッファで「最後のN行」を高速に出す

## 問題
標準入力からログ行（1行＝最大200文字）が順に与えられる。  
最終的に **最後の N 行**だけを、**入力順（古い→新しい）**で出力せよ。

ただし、入力件数 M は大きい可能性があるため、**全行を保存してはいけない**（メモリ節約）。  
**リングバッファ（循環配列）**を使って、常に「直近N行」だけ保持すること。

---

## 入力形式
- 1行目: `N M`（1 ≤ N ≤ 100000, 1 ≤ M ≤ 1000000）
- 2行目以降: ログ文字列 M 行（各行は最大200文字、空行もあり得る）

---

## 出力形式
最後の N 行を、元の時系列（古い→新しい）でそのまま出力する。  
（ただし M < N の場合は、存在する全行を入力順で出力）

---

## 例

### 入力
```
3 5
a
b
c
d
e
```

### 出力
```
c
d
e
```


---

## 要求仕様（重要）
- 計算量: **O(M)**  
- 追加メモリ: **O(N)**（各行最大200文字分）
- **fgets** で行を読み取ること（空行対応のため）
- 行末の改行 `\n` は **残しても消してもOK**（出力が同じなら）

---

## ヒント
- `char (*buf)[201] = malloc(sizeof(char[201]) * N);` みたいに確保すると楽。
- 書き込み位置 `head` を `(head + 1) % N` で回す。
- 最後に「どこから出力開始か」を考える：  
  - `count = min(M, N)`  
  - `start = (M <= N) ? 0 : head`（この `head` の意味を自分の実装で一致させること）

---

## 追加チャレンジ（時間あれば）
- `malloc` 失敗時のハンドリング
- `N` が 1 のときも崩れないことを確認
- 入力の行が200文字を超えるケースを「仕様外として切り捨て」で扱ってよいが、コメントで明記する

---