# 今日のPython課題: "Rolling Bloom"（ビット集合でストリーミング重複検知）

## 概要
大量のID（整数）がストリームで流れてきます。  
直近 **W 件**の範囲で「**すでに出たことがあるIDか**」を高速に判定し、各入力ごとに結果を出力してください。

ただし、メモリ節約のために **Bloom Filter（確率的集合）** を使います（= たまに誤って「見た」と判定してもOK）。

## 入力
- 1行目: `W K M`
  - `W` : ローリング窓（直近何件を対象にするか）
  - `K` : ハッシュ関数の本数
  - `M` : ビット配列の長さ（0..M-1）
- 2行目以降: 整数 `x` が1行ずつ（EOFまで）

## 出力
各 `x` について1行出力:
- 直近W件の範囲で「見た可能性がある」なら `1`
- 「見ていないことが確実」なら `0`

## 仕様（重要）
- Bloom Filterを **ローリング** にするため、次の方式を採用します。
  - `W` 件ごとに「世代」を切り替える **2面方式**（current / previous）を使う
  - 判定は `current OR previous` に対して行う
  - 追加は `current` のみに行う
  - 入力数が `W` 件進んだら:
    - `previous = current`
    - `current` を全0にリセット
- ハッシュは `K` 個必要。外部ライブラリ禁止（標準ライブラリのみ）。
  - 例: `hashlib.blake2b` を使い、seedを変えて `K` 個のインデックスを作る（推奨）
  - `idx = digest_as_int % M`

## 制約（目安）
- `1 <= W <= 200000`
- `1 <= K <= 8`
- `M <= 5_000_000`（ビット配列は `bytearray((M+7)//8)` 推奨）
- 入力行数は多い想定（I/O最適化推奨）

## 例
入力:
```
5 3 32
10
20
10
30
10
20
```


出力（例の一つ。Bloomなので、理論上は1が増えることはあり得る）:
```
0
0
1
0
1
1
```


## 実装ヒント
- ビット操作:
  - set: `bits[i>>3] |= 1 << (i & 7)`
  - get: `(bits[i>>3] >> (i & 7)) & 1`
- `current` と `previous` を `bytearray` 2本持つ
- 判定時は「両方を読む」だけ（ORした配列を毎回作るのは遅い）

## 追加チャレンジ（余裕があれば）
1. `K` を変えた時の誤判定率の体感（ログ出力など）
2. `W` を厳密にしたい場合（世代数を増やして近似を改善する：例 4面方式）

---
提出物: `main.py`（標準入力→標準出力）