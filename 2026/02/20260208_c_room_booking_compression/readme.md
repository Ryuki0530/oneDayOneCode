# Daily C Challenge — "Room Booking Compression"

## 問題
1日（0〜10^9分）の中で、会議室の予約がN件ある。
各予約は半開区間 `[S, E)`（S分以上E分未満）で表され、同時に複数予約が重なることがある。

あなたの仕事は次の2つを求めること：

1. **最大同時予約数**（同時に何件重なっているかの最大値）
2. **最大同時予約数を達成している総時間（分）**  
   例：最大が3で、3が成立している時間帯の合計が120分なら `120`

## 入力形式
- 1行目: `N`（1 ≤ N ≤ 200000）
- 続くN行: `S E`（0 ≤ S < E ≤ 1000000000）

## 出力形式
- 1行目: 最大同時予約数 `maxK`
- 2行目: `maxK` を達成している総時間 `totalMinutes`

## 例
入力:
```
4
10 20
15 25
18 30
40 50
```
出力:
```
3
2
```


説明:
最大同時予約数は3。成立区間は `[18,20)` なので 2 分。

## 要求
- O(N log N) 以内で解くこと（Nが20万ある）
- 時刻が最大10^9なので、配列を直接持つのは禁止（＝**座標圧縮**が必要）

## ヒント（解法の骨）
- すべての `S` と `E` を集めてソートし重複排除 → 圧縮座標 `t[i]`
- 差分配列 `diff` を用意し、各予約 `[S,E)` について
  - `diff[idx(S)] += 1`
  - `diff[idx(E)] -= 1`
- 圧縮軸を左から走査して累積和 `cur` を更新すると、その区間 `[t[i], t[i+1])` の同時予約数が `cur`
- `cur` が最大値なら、その区間長 `t[i+1]-t[i]` を `totalMinutes` に加算

## 実装注意
- `totalMinutes` は最大で 10^9 * 200000 近くまで行き得るので `long long` を使う
- `[t[i], t[i+1])` の長さが0のケース（同じ時刻が連続）は重複排除していれば起きにくいが、念のため考慮してもよい

## 追加チャレンジ（余裕があれば）
- 最大同時予約数を達成する区間をすべて列挙して出力せよ（区間数は多いかもしれないのでフォーマット設計に注意）