# 今日の課題：遅延削除つきタスクスケジューラ（優先度付き）

## 概要
コマンド列を処理して、タスクを登録・取消し・実行する簡易スケジューラを実装してください。  
**ポイントは「heap（優先度付きキュー）から任意要素を消せない」問題を、遅延削除で解決すること**です。

---

## 仕様

あなたは次の 3 種類のコマンドを順に処理します。

### 1) `ADD id t p`
- `id`（整数）というタスクを登録する
- 実行可能時刻：`t`（整数）
- 優先度：`p`（整数、**大きいほど優先**）
- すでに同じ `id` が「未実行で存在」する場合は、**上書き**（古い登録は無効化）してよい

### 2) `CANCEL id`
- `id` のタスクを **取消し**（未実行なら無効化）
- 存在しない / すでに実行済みでもエラーにせず無視

### 3) `RUN now`
- 時刻 `now` までに実行可能（`t <= now`）なタスクのうち、次の順で **1つだけ** 実行する  
  1. 優先度 `p` が最大  
  2. `t` が最小  
  3. `id` が最小
- 実行したら、その `id` を出力する
- 実行可能なタスクが無ければ `-1` を出力する

---

## 入力形式
1行目に整数 `Q`（コマンド数）  
続く `Q` 行にコマンドが与えられる。

---

## 出力形式
各 `RUN` コマンドごとに 1 行、実行したタスクの `id`（または `-1`）を出力する。

---

## 制約（目安）
- `1 <= Q <= 200000`
- `id, t, p, now` は `0 <=` で `10^9` 程度
- 全体が **O(Q log Q)** 程度で通る実装を狙う（線形探索で毎回探すのは負け）

---

## 実装ヒント（核心）
- heap には「実行候補」を積む  
  比較キーは `(-p, t, id)`（優先度は大きいほど優先なので `-p`）
- `ADD` や `CANCEL` のたびに heap から古い要素を直接消すのは無理なので、
  - `dict[id] = (t, p, alive_flag)` や `dict[id] = version` みたいに状態を持つ
  - heap から取り出したときに「これは最新で有効か？」を検査し、違えば捨てて次を pop（これが遅延削除）

---

## サンプル

### 入力
```
10
ADD 1 5 10
ADD 2 3 10
RUN 2
RUN 3
ADD 3 3 5
CANCEL 2
RUN 3
ADD 2 1 100
RUN 3
RUN 10
```


### 出力
```
-1
2
3
2
1
```


### 説明（ざっくり）
- `RUN 2` 時点では `t<=2` がいないので `-1`
- `RUN 3` で `id=2` が実行（同優先度なら時刻が小さい方）
- …以降、取消しや上書きが入るので「heapに残る古いデータ」を捨てる処理が必要

---

## 仕上げ条件（これ満たせば勝ち）
- 上書き（同じidの再ADD）を正しく扱える
- CANCEL 済みのゴミが heap に残っても RUN が壊れない
- Q が大きくても遅くならない（毎回全探索しない）

---

## 追加チャレンジ（時間あれば）
- `RUN now` で「実行したタスクの (id, t, p)」も出す版に拡張
- 「実行可能タスクが尽きるまで全部実行」コマンド `RUNALL now` を追加
