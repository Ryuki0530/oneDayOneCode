# Today’s C Challenge: “Bitset-Backed ID Allocator”

## 概要
大量のID（0〜N-1）があり、次の操作を高速に処理する「ID割り当て器」を実装してください。  
メモリ効率のため、**bitset（ビット配列）**で管理します。

---

## 入力
1行目：`N Q`  
- `N`：IDの総数（1 <= N <= 10^7）
- `Q`：クエリ数（1 <= Q <= 2*10^5）

続くQ行：以下のいずれか
- `ALLOC`  
  - **未使用**のIDのうち最小のものを割り当て、`id` を出力  
  - もし空きが無ければ `-1` を出力
- `FREE x`  
  - `x` を未使用に戻す（すでに未使用なら何もしない）
- `TEST x`  
  - `x` が使用中なら `1`、未使用なら `0` を出力

---

## 出力
`ALLOC` と `TEST` のたびに結果を出力。

---

## 要求仕様（重要）
- ID管理は **ビット演算**で行うこと（`uint32_t` または `uint64_t` 配列）。
- `ALLOC` を高速にする工夫を入れること  
  - 例：直近の探索位置（カーソル）を持つ、`__builtin_ctz` / `__builtin_ctzll` を使う、など
- 計算量の目安：
  - `TEST/FREE` はほぼ O(1)
  - `ALLOC` は平均的に高速（全探索を毎回しない）

---

## 実装ヒント
- `bits[i]` の各ビットがIDの使用状態（1=使用中, 0=空き）
- ID `x` の位置
  - word index: `w = x / WORD_BITS`
  - bit index:  `b = x % WORD_BITS`
- `ALLOC` は「0ビットを探す」問題なので、`~bits[w]` を見て、0が存在するwordを探すと早い
- `__builtin_ctz` は「最下位の1が何ビット目か」を返す（0入力は未定義なので注意）

---

## サンプル
入力：
```
10 8
ALLOC
ALLOC
TEST 1
FREE 0
ALLOC
TEST 0
FREE 9
ALLOC
```

出力:
```
0
1
1
0
0
2
```


---

## 追加チャレンジ（余裕があれば）
- `ALLOC k`：空きIDをk個連続で確保できる最小開始位置を返す（無理なら -1）
  - これ、途端にOSっぽくなって楽しいです。
  