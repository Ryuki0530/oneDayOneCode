# 今日のC課題：簡易LRUキャッシュ（O(1)想定）

## 問題
容量 `K` のキャッシュを実装してください。コマンド列を処理し、`get` の結果を出力します。

- `put key value`：キー `key` に値 `value` を格納（既存なら更新）。この操作でそのキーは「最新アクセス」になる。
- `get key`：存在すれば値を出力し、そのキーを「最新アクセス」にする。存在しなければ `-1` を出力。
- キャッシュが満杯のときに新規 `put` が来たら、「最も古い（最近使われていない）要素」を1つ追い出す（LRU）。

## 入力
```
K Q
(以下Q行)
cmd ...
```


- `1 <= K <= 2000`
- `1 <= Q <= 200000`
- `key` は `1..200000` の整数
- `value` は 32bit 整数

## 出力
`get` が来た回数だけ、各行に結果を出力。

## 例
入力:
```
2 8
put 1 10
put 2 20
get 1
put 3 30
get 2
put 4 40
get 1
get 3
```

出力:
```
10
-1
-1
30
```


## 実装条件（時短用の縛り）
- 連想配列は使わず、`key` の上限が小さいので **配列**で管理してOK（存在フラグ/ノード参照など）。
- LRU順は **双方向連結リスト**で管理（先頭=最新、末尾=最古）。
- 期待計算量：各操作ほぼO(1)

## ヒント
- `struct Node { int key, value; int prev, next; }` のように「配列で疑似ポインタ」方式にすると楽。
- `head` / `tail` をダミーノードにすると、挿入・削除の分岐が減る。

## 仕上げ（余力があれば）
- `put` の更新と新規挿入で処理を共通化して、バグりにくくする。

