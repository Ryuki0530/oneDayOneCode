# Today’s C Challenge: “Endian Detective”

## 問題
32bitの符号なし整数 `x` が標準入力から与えられる。

次の3つを **すべて** 出力せよ（各行に1つ）：

1. `x` を **ビッグエンディアン** とみなしたときのバイト列（16進・2桁×4、上位バイト→下位バイト）
2. `x` を **リトルエンディアン** とみなしたときのバイト列（16進・2桁×4、上位バイト→下位バイト）
3. `x` の **エンディアンを入れ替えた値**（= バイト逆順にした 32bit 値）を `0x????????` 形式で出力

ここで「バイト列」は、例えば `DE AD BE EF` のようにスペース区切りで出力すること。

## 入力
- 1行：`x`（`0 <= x <= 4294967295`）
  - 入力は10進でも16進（`0x`付き）でもよい（`strtoul` を使う想定）

## 出力形式
- 1行目：Big-endian bytes: `HH HH HH HH`
- 2行目：Little-endian bytes: `HH HH HH HH`
- 3行目：Swapped: `0xHHHHHHHH`

## 例
入力:
- `0x12345678`

出力:
- Big-endian bytes: `12 34 56 78`
- Little-endian bytes: `78 56 34 12`
- Swapped: `0x78563412`

## 制約・注意
- **ビット演算だけ**で実装すること（配列で1byteずつ詰め替えるのはOKだが、最終的な入れ替えはシフト/AND/ORでやること）
- 環境依存の `htonl` / `ntohl` は使わない
- `uint32_t` を使うこと（`#include <stdint.h>`）
- 16進出力は必ず2桁固定（`%02X`）にすること

## ヒント（使うと良い標準機能）
- `strtoul(s, NULL, 0)` で `0x` 付き/無し両対応で数値化できる
- 1バイト抽出：`(x >> 24) & 0xFF` のようにする
- バイトスワップ（例）：
  - `((x & 0x000000FFu) << 24) | ((x & 0x0000FF00u) << 8) | ((x & 0x00FF0000u) >> 8) | ((x & 0xFF000000u) >> 24)`

## 追加チャレンジ（任意）
- 実行環境がリトルエンディアンかどうかを判定して `Host endian: little/big` を追加表示せよ（ユニオン or `uint16_t` を使った判定でOK）

# 解説メモ（関連モジュール/考え方）

- `stdint.h` の `uint32_t` は「必ず32bit」の整数型なので、この手のバイト操作と相性が良いです。
- `strtoul` の第3引数に `0` を渡すと、`0x` なら16進、そうでなければ10進、という“賢い解釈”をしてくれます。
- エンディアンの話は「メモリ上での並び順」なので、今回みたいに **数値からバイトを取り出して並べる** と、OS/CPUに依存しない確実な確認ができます。
- バイトスワップは「マスクで欲しい1バイトだけ残す → 目的位置までシフト → ORで合成」という3手で書けます。地味だけど強い基本技です。